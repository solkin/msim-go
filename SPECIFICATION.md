# Спецификация протокола mSIM

**Авторы:** Мусатов М.Д., Солкин И.В.

---

## Введение

mSIM — лёгкий расширяемый протокол для обмена текстовыми сообщениями. Протокол разработан с учётом нетребовательности к ресурсам, масштабируемости и простоты реализации.

### Суть протокола

Протокол mSIM использует клиент-серверную архитектуру. Клиент подключается к серверу по TCP (порт 3215). Обмен данными происходит в виде пакетов.

Каждый пакет представляет собой одну строку в кодировке UTF-8, заканчивающуюся символом новой строки (`\n`). Это позволяет использовать протокол через telnet или netcat.

Структура пакета может быть в одном из следующих форматов:

1. **`TYPE\n`** — пакет только с типом (например, `ping\n`, `bye\n`, `list\n`, `stat\n`)

2. **`TYPE|CONTENT\n`** — пакет с типом и содержимым (например, `help\n`, `stat|user@example.com\n`, `hist|contact@example.com\n`)

3. **`TYPE|DESTINATION|CONTENT\n`** — пакет с типом, получателем и содержимым (например, `msg|recipient@example.com|Hello!\n`, `ack|sender@example.com|2024-01-01T12:00:00Z\n`)

Где:
- `TYPE`: Тип пакета (обязательное поле). Всегда первое поле в пакете.
- `DESTINATION`: Логин получателя (для исходящих пакетов от клиента) или отправителя (для входящих пакетов от сервера). Опциональное поле, присутствует только в формате с тремя частями. Для пакетов, адресованных серверу, это поле обычно отсутствует.
- `CONTENT`: Содержимое пакета. Может быть пустым или содержать дополнительные поля, разделённые символом вертикальной черты `|` (неэкранированным) или запятой `,` (для списков), в зависимости от типа пакета. Внутри `CONTENT` дополнительные поля также могут разделяться неэкранированным символом `|`.

**Важно:** Разделитель `|` между основными частями пакета (TYPE, DESTINATION, CONTENT) не экранируется. Экранирование применяется только к символам внутри самих полей. Например, в пакете `msg|user@example.com|Hello\|World\n` символ `|` между `msg` и `user@example.com` и между `user@example.com` и `Hello\|World` является разделителем полей, а `\|` внутри `Hello\|World` — экранированным символом, который будет интерпретирован как обычный `|`.

Пакеты разделяются символом новой строки (`\n`). Каждый пакет должен заканчиваться этим символом.

### Экранирование символов

Для передачи специальных символов внутри полей используется экранирование через обратный слэш (`\`). Экранируются следующие символы:

- `\|` — вертикальная черта (разделитель полей)
- `\,` — запятая (разделитель в списках)
- `\\` — обратный слэш
- `\n` — символ новой строки (внутри поля, не разделитель пакета)
- `\r` — символ возврата каретки

Обратный слэш перед любым другим символом интерпретируется как обычный обратный слэш (экранирование игнорируется).

Примеры:
- Для передачи логина `user|name` нужно написать `user\|name`
- Для передачи текста с новой строкой: `Первая строка\nВторая строка`
- Для передачи обратного слэша: `путь\\к\\файлу`
- Для передачи запятой в списке контактов: `id,with\,comma|nick`

**Таймаут соединения:** Сервер разрывает соединение, если клиент не подаёт признаков жизни в течение 120 секунд. Для поддержания соединения используйте команду `ping` (см. [Проверка связи](#проверка-связи)).

## Описание протокола

### Базовые типы пакетов

#### Успех

Пакет с типом `ok` оповещает об успешном завершении операции. В поле `CONTENT` может быть указано название операции (опционально). Формат: `ok|operation\n` или просто `ok\n`

#### Неудача

Пакет с типом `fail` оповещает о том, что запрошенную операцию не удалось выполнить. Это включает все типы ошибок: отказы в выполнении операции, внутренние ошибки сервера, неизвестные типы пакетов и т.д.

Формат: `fail|operation|description\n`

Где:
- `operation` — название операции, которая не удалась (например, `auth`, `reg`, `add`). Для внутренних ошибок, не связанных с конкретной операцией, это поле пустое.
- `description` — описание ошибки (опционально, может быть пустым). Если описание отсутствует, пакет может иметь формат `fail|operation|\n` или просто `fail|\n` для внутренних ошибок.

Примеры:
- `fail|auth|\n` — ошибка авторизации без описания
- `fail|auth|Invalid credentials\n` — ошибка авторизации с описанием
- `fail||Internal server error\n` — внутренняя ошибка сервера
- `fail|\n` — общая ошибка без деталей

### Основные возможности протокола

#### Проверка связи {#проверка-связи}

Используется для проверки связи и поддержания соединения в активном состоянии.

**Запрос (от клиента к серверу):**
```
<< ping\n
```

**Ответ сервера:**
```
>> pong\n
```

Пример:
```
ping
pong
```

#### Завершение сессии {#bye}

Используется для нормального завершения сессии. Клиент может отправить пакет `bye` для корректного отключения от сервера. Сервер также отправляет пакет `bye` при принудительном завершении сессии с указанием причины.

**Завершение сессии клиентом:**
```
<< bye\n
```

После отправки пакета `bye` клиент может закрыть соединение. Сервер также закрывает соединение после отправки ответа.

**Завершение сессии сервером:**

Сервер отправляет пакет `bye` при принудительном завершении сессии. Формат: `bye|reason|details\n`

Где:
- `reason` — причина завершения сессии:
  - `timeout` — таймаут (клиент не подавал признаков жизни в течение установленного времени)
  - `maintenance` — сервер уходит на обслуживание
  - `restart` — сервер перезагружается
- `details` — дополнительная информация (опционально):
  - Для `maintenance`: время завершения обслуживания в формате ISO 8601 (UTC), например `2024-01-01T13:00:00Z`
  - Для `restart`: время завершения перезагрузки в формате ISO 8601 (UTC), например `2024-01-01T12:05:00Z`
  - Для `timeout`: может быть пустым

Примеры:

Завершение сессии клиентом:
```
bye
```

Завершение сессии по таймауту:
```
>> bye|timeout|\n
```

Сервер уходит на обслуживание до 13:00 UTC:
```
>> bye|maintenance|2024-01-01T13:00:00Z\n
```

Сервер перезагружается, завершение в 12:05 UTC:
```
>> bye|restart|2024-01-01T12:05:00Z\n
```

**Примечание:** После получения пакета `bye` от сервера клиент должен закрыть соединение. После отправки пакета `bye` клиентом сервер закрывает соединение.

#### Справка {#help}

Используется для получения списка поддерживаемых команд.

**Запрос справки (от клиента к серверу):**
```
<< help\n
```

**Ответ сервера:**
```
>> help|ping,auth,reg,msg,ack,hist,hclear,offmsg,stat,list,add,ren,del,bye,help,fsnd,facc,fdec,fcan,fst\n
```

Ответ приходит в виде списка поддерживаемых команд, разделенных запятой (`,`).

Пример:
```
help
help|ping,auth,reg,msg,ack,hist,hclear,offmsg,stat,list,add,ren,del,bye,help,fsnd,facc,fdec,fcan,fst
```

**Примечание:** Команда `help` доступна без авторизации.

#### Авторизация {#auth}

Используется для авторизации на сервере.

**Запрос (от клиента к серверу):**
```
<< auth|login|password\n
```

**Ответ сервера:**
```
>> ok|auth\n
```

При неверной паре логин-пароль сервер отвечает `fail|auth|Invalid credentials\n`. Если клиент уже авторизован, сервер отправляет `ok|auth\n`.

Пример:
```
auth|myuser|mypass
ok|auth
```

#### Регистрация {#register}

Используется для создания новой учётной записи на сервере.

**Запрос (от клиента к серверу):**
```
<< reg|login|password\n
```

**Ответ сервера:**
```
>> ok|reg\n
```

Если аккаунт уже существует, сервер отвечает `fail|reg|User already exists\n`.

Пример:
```
reg|newuser|newpass
ok|reg
```

### Текстовые сообщения

#### Сообщение {#message}

Используется для отправки обычных текстовых сообщений адресату.

**Исходящее сообщение (от клиента к серверу):**
```
<< msg|friend|Привет!\n
```

**Входящее сообщение (от сервера к клиенту):**
```
>> msg|sender|Привет!|2024-01-01T12:00:00Z\n
```

В входящих сообщениях после текста добавляется время отправки в формате ISO 8601 (UTC). Формат: `YYYY-MM-DDTHH:mm:ssZ` (например, `2024-01-01T12:00:00Z`). Время всегда серверное и в UTC. Это время используется как уникальный идентификатор сообщения для подтверждения доставки.

Примеры:

Исходящее сообщение:
```
msg|friend@example.com|Привет, как дела?
```

Входящее сообщение:
```
msg|friend@example.com|Привет, как дела?|2024-01-01T12:00:00Z
```

Сообщение с экранированием (символ `|`):
```
msg|friend@example.com|Цена: 100\|200 рублей
```

Многострочное сообщение:
```
msg|friend@example.com|Первая строка\nВторая строка
```

#### Подтверждение доставки {#ack}

После получения входящего сообщения клиент может отправить подтверждение доставки серверу. Это позволяет отправителю узнать, что сообщение было доставлено получателю.

**Подтверждение доставки (от клиента к серверу):**
```
<< ack|sender|2024-01-01T12:00:00Z\n
```

Где:
- `sender` — логин отправителя сообщения
- `2024-01-01T12:00:00Z` — время отправки сообщения (timestamp из входящего сообщения), используемое как идентификатор

**Ответ сервера:**
```
>> ok|ack\n
```

Сервер пересылает подтверждение доставки отправителю сообщения.

**Подтверждение доставки (от сервера к отправителю):**
```
>> ack|recipient|2024-01-01T12:00:00Z\n
```

Где:
- `recipient` — логин получателя, который подтвердил доставку
- `2024-01-01T12:00:00Z` — время отправки исходного сообщения (идентификатор)

Пример:

Получение сообщения и подтверждение:
```
msg|friend@example.com|Привет!|2024-01-01T12:00:00Z
ack|friend@example.com|2024-01-01T12:00:00Z
ok|ack
```

Получение подтверждения отправителем:
```
ack|me@example.com|2024-01-01T12:00:00Z
```

**Примечание:** Подтверждение доставки опционально, но рекомендуется.

#### История сообщений {#hist}

Клиент может запросить историю сообщений с конкретным контактом. История хранится на сервере и включает как отправленные, так и полученные сообщения, а также их статус доставки.

**Запрос истории (от клиента к серверу):**
```
<< hist|contact@example.com\n
```

Или с ограничением количества сообщений:
```
<< hist|contact@example.com|100\n
```

Или с отступом и ограничением:
```
<< hist|contact@example.com|50|100\n
```

Где:
- Первый параметр (опционально) — максимальное количество сообщений (limit). Если не указан, возвращаются все сообщения.
- Второй параметр (опционально) — отступ (offset), количество сообщений, которые нужно пропустить от начала истории. Если не указан, используется 0.

Если не указаны оба параметра, сервер возвращает все доступные сообщения.

**Примечание:** Формат `hist|contact|offset|limit` означает: пропустить `offset` сообщений, затем вернуть до `limit` сообщений.

**Ответ сервера:**
```
>> hist|contact@example.com|msg|sender|Текст сообщения|2024-01-01T12:00:00Z|ackn,msg|recipient|Другое сообщение|2024-01-01T12:05:00Z|sent\n
```

Ответ приходит в виде списка сообщений, где каждое сообщение представлено в формате `msg|sender|text|timestamp|status`, сообщения разделены запятой (`,`).

Где:
- `sender` — логин отправителя (может быть текущий пользователь или контакт)
- `text` — текст сообщения
- `timestamp` — время отправки в формате ISO 8601 (UTC)
- `status` — статус доставки: `ackn` (доставлено, получено подтверждение ack) или `sent` (отправлено, но подтверждение не получено)

Примеры:

Запрос всех сообщений:
```
hist|friend@example.com
hist|friend@example.com|msg|me@example.com|Привет!|2024-01-01T12:00:00Z|ackn,msg|friend@example.com|Привет!|2024-01-01T12:01:00Z|ackn
```

Запрос первых 100 сообщений:
```
hist|friend@example.com|100
```

Запрос с отступом 50, максимум 100 сообщений:
```
hist|friend@example.com|50|100
```

#### Очистка истории {#hclear}

Клиент может очистить историю сообщений с конкретным контактом.

**Очистка истории (от клиента к серверу):**
```
<< hclear|contact@example.com\n
```

**Ответ сервера:**
```
>> ok|hclear\n
```

Если история успешно очищена, сервер отвечает `ok|hclear\n`. Если контакта нет в списке, сервер отвечает `fail|hclear|Contact not found\n`.

Пример:
```
hclear|friend@example.com
ok|hclear
```

#### Оффлайн-сообщения {#offmsg}

Клиент может запросить количество сообщений, полученных с момента последнего отключения от сервера.

**Запрос (от клиента к серверу):**
```
<< offmsg\n
```

**Ответ сервера:**
```
>> offmsg|friend1@example.com|5,friend2@example.com|2\n
```

Ответ приходит в виде списка, где каждый элемент представлен в формате `contact|count`, элементы разделены запятой (`,`). Где:
- `contact` — логин отправителя
- `count` — количество сообщений, полученных от этого контакта с момента последнего отключения текущего пользователя

Если оффлайн-сообщений нет, сервер отвечает пустым списком:
```
>> offmsg|\n
```

Примеры:

Запрос оффлайн-сообщений:
```
offmsg
offmsg|friend1@example.com|5,friend2@example.com|2
```

Если нет оффлайн-сообщений:
```
offmsg
offmsg|
```

**Примечание:** Оффлайн-сообщениями считаются сообщения, полученные в период между последним отключением (`last_offline`) и текущим подключением (`last_online`) пользователя. Это позволяет узнать, сколько сообщений пришло, пока пользователь был оффлайн.

### События статуса контактов

Сервер автоматически отправляет клиенту уведомления о подключении и отключении пользователей из его списка контактов.

#### Запрос статусов контактов

Клиент может запросить текущие статусы (онлайн/оффлайн) всех пользователей из своего списка контактов.

**Запрос статусов (от клиента к серверу):**
```
<< stat\n
```

Или для запроса статуса конкретного пользователя:

```
<< stat|user@example.com\n
```

**Ответ сервера:**

При запросе всех контактов:
```
>> stat|user1@example.com|on|2024-01-01T12:00:00Z,user2@example.com|off|2024-01-01T11:30:00Z\n
```

При запросе конкретного пользователя:
```
>> stat|user@example.com|on|2024-01-01T12:00:00Z\n
```

Или если пользователь оффлайн:
```
>> stat|user@example.com|off|2024-01-01T11:30:00Z\n
```

Ответ приходит в виде списка статусов, где каждый статус представлен в формате `user|status|last_seen`, статусы разделены запятой (`,`). Где:
- `status` — может быть `on` (онлайн) или `off` (оффлайн)
- `last_seen` — время последнего изменения статуса в формате ISO 8601 (UTC). Для онлайн-пользователей это время подключения, для оффлайн — время отключения.

Если указанный пользователь не существует, сервер отвечает `fail|stat|User not found\n`.

Примеры:

Запрос статусов всех контактов:
```
stat
stat|friend1@example.com|on|2024-01-01T12:00:00Z,friend2@example.com|off|2024-01-01T11:30:00Z
```

Запрос статуса конкретного пользователя:
```
stat|friend1@example.com
stat|friend1@example.com|on|2024-01-01T12:00:00Z
```

Если пользователь не существует:
```
stat|nonexistent@example.com
fail|stat|User not found
```

#### Подключение пользователя {#on}

Когда пользователь из списка контактов подключается к серверу, клиент получает уведомление.

**Событие подключения (от сервера к клиенту):**
```
>> on|user@example.com|2024-01-01T12:00:00Z\n
```

Где:
- `user@example.com` — логин пользователя из списка контактов, который подключился
- `2024-01-01T12:00:00Z` — время подключения в формате ISO 8601 (UTC)

Пример:
```
on|friend@example.com|2024-01-01T12:00:00Z
```

#### Отключение пользователя {#off}

Когда пользователь из списка контактов отключается от сервера, клиент получает уведомление.

**Событие отключения (от сервера к клиенту):**
```
>> off|user@example.com|2024-01-01T12:30:00Z\n
```

Где:
- `user@example.com` — логин пользователя из списка контактов, который отключился
- `2024-01-01T12:30:00Z` — время отключения в формате ISO 8601 (UTC)

Пример:
```
off|friend@example.com|2024-01-01T12:30:00Z
```

**Примечание:** События о статусе отправляются только для пользователей из списка контактов клиента.

### Работа со списком контактов

#### Запрос списка

Запрашивает у сервера список контактов. Ответ приходит в виде списка контактов, где каждый контакт представлен в формате `id|nick`, контакты разделены запятой (`,`).

```
<< list\n

>> list|friend@m1kc.tk|friend,vasya@poupkine.com|vasya,one@m1kc.tk|number\n
```

Пример:
```
list
list|friend@m1kc.tk|friend,vasya@poupkine.com|vasya,one@m1kc.tk|number
```

#### Добавление контакта

Для добавления контакта используется пакет типа `add`. В поле `CONTENT` передаются id контакта и назначаемый ему ник. Если ник не указан, в качестве ника будет использован id контакта.

**Важно:** В список контактов можно добавлять только существующих пользователей. Если указанный пользователь не существует в системе, сервер отвечает пакетом `fail|add|User not found\n`.

Типичный случай:

```
<< add|wellie@server.ru|One more friend\n

>> ok|add\n
```

Или без указания ника (ник будет равен id контакта):

```
<< add|wellie@server.ru\n

>> ok|add\n
```

Если пользователь не существует:
```
<< add|nonexistent@server.ru|Friend\n

>> fail|add|User not found\n
```

Примеры:

С указанием ника:
```
add|wellie@server.ru|One more friend
ok|add
```

Без указания ника (ник будет равен id контакта):
```
add|wellie@server.ru
ok|add
```

Если пользователь не существует:
```
add|nonexistent@server.ru|Friend
fail|add|User not found
```

#### Переименование контакта

Контакты переименовываются с помощью пакета типа `ren`. В поле `CONTENT` передаются id контакта и его новый ник. Если такого контакта в списке нет, сервер отвечает `fail|ren|Contact not found\n`.

```
<< ren|friend@m1kc.tk|Enemy\n

>> ok|ren\n
```

Пример:
```
ren|friend@m1kc.tk|Enemy
ok|ren
```

#### Удаление контакта

Для удаления контакта используется пакет типа `del`. В поле `CONTENT` передаётся id контакта. Если такого контакта в списке нет, сервер отвечает `fail|del|Contact not found\n`.

```
<< del|one@m1kc.tk\n

>> ok|del\n
```

Пример:
```
del|one@m1kc.tk
ok|del
```

### Передача файлов

Протокол mSIM поддерживает прямую передачу файлов между клиентами через TCP прокси на сервере. Передача файлов происходит в три этапа: инициация, принятие/отклонение и сама передача через выделенные порты.

**Важно:** Для передачи файлов можно использовать стандартные утилиты, такие как `nc` (netcat), `cat` и другие инструменты работы с TCP сокетами.

#### Инициация передачи файла {#fsnd}

Отправитель инициирует передачу файла, указывая получателя, имя файла, размер и опциональный хеш для проверки целостности.

**Запрос (от клиента к серверу):**
```
<< fsnd|recipient|filename|size|hash\n
```

Где:
- `recipient` — логин получателя
- `filename` — имя файла
- `size` — размер файла в байтах
- `hash` — хеш файла (например, `sha256:abc123...`) для проверки целостности (опционально, можно оставить пустым)

**Ответ сервера:**
```
>> ok|fsnd|SESSION_ID|EXPIRES_IN\n
```

Где:
- `SESSION_ID` — уникальный идентификатор сессии передачи (например, `f4a3b2c1`)
- `EXPIRES_IN` — время в секундах до истечения сессии (обычно 300 секунд для ожидания принятия)

**Уведомление получателя (от сервера к получателю):**
```
>> fsnd|sender|filename|size|hash|SESSION_ID\n
```

Примеры:

Инициация передачи:
```
fsnd|bob@server.com|photo.jpg|2048000|sha256:abc123
ok|fsnd|f4a3b2c1|300
```

Уведомление получателя:
```
fsnd|alice@server.com|photo.jpg|2048000|sha256:abc123|f4a3b2c1
```

#### Принятие файла {#facc}

Получатель принимает передачу файла. После принятия сервер выделяет два TCP порта: один для загрузки (upload) отправителем, другой для скачивания (download) получателем.

**Запрос (от получателя к серверу):**
```
<< facc|sender|SESSION_ID\n
```

Где:
- `sender` — логин отправителя (опционально, для дополнительной проверки)
- `SESSION_ID` — идентификатор сессии из уведомления

**Ответ сервера получателю:**
```
>> ok|facc|DOWNLOAD_PORT\n
```

Где:
- `DOWNLOAD_PORT` — номер TCP порта для скачивания файла

**Уведомление отправителя (от сервера к отправителю):**
```
>> facc|recipient|SESSION_ID|UPLOAD_PORT\n
```

Где:
- `recipient` — логин получателя, который принял файл
- `SESSION_ID` — идентификатор сессии
- `UPLOAD_PORT` — номер TCP порта для загрузки файла

Примеры:

Принятие файла:
```
facc|alice@server.com|f4a3b2c1
ok|facc|35001
```

Уведомление отправителя:
```
facc|bob@server.com|f4a3b2c1|35002
```

#### Передача файла через netcat

После принятия файла обе стороны могут использовать стандартные утилиты для передачи.

**Отправитель загружает файл:**
```bash
cat photo.jpg | nc server.address 35002
# или
nc server.address 35002 < photo.jpg
```

**Получатель скачивает файл:**
```bash
nc server.address 35001 > photo.jpg
```

Сервер выступает как TCP прокси, пробрасывая данные от порта загрузки к порту скачивания. Соединение закрывается автоматически после завершения передачи.

**Примечание:** Передача происходит напрямую через сервер без дополнительной обработки. Данные передаются "как есть" в бинарном виде.

#### Отклонение файла {#fdec}

Получатель может отклонить передачу файла.

**Запрос (от получателя к серверу):**
```
<< fdec|sender|SESSION_ID|reason\n
```

Где:
- `sender` — логин отправителя (опционально)
- `SESSION_ID` — идентификатор сессии
- `reason` — причина отклонения (опционально)

**Ответ сервера:**
```
>> ok|fdec\n
```

**Уведомление отправителя (от сервера к отправителю):**
```
>> fdec|recipient|SESSION_ID|reason\n
```

Примеры:

Отклонение файла:
```
fdec|alice@server.com|f4a3b2c1|not interested
ok|fdec
```

Уведомление отправителя:
```
fdec|bob@server.com|f4a3b2c1|not interested
```

#### Отмена передачи {#fcan}

Любая из сторон может отменить передачу файла в любой момент.

**Запрос (от клиента к серверу):**
```
<< fcan|user|SESSION_ID|reason\n
```

Где:
- `user` — логин другой стороны (отправителя или получателя)
- `SESSION_ID` — идентификатор сессии
- `reason` — причина отмены (опционально)

**Ответ сервера:**
```
>> ok|fcan\n
```

**Уведомление другой стороны (от сервера):**
```
>> fcan|user|SESSION_ID|reason\n
```

Примеры:

Отмена передачи:
```
fcan|bob@server.com|f4a3b2c1|changed my mind
ok|fcan
```

Уведомление другой стороны:
```
fcan|alice@server.com|f4a3b2c1|changed my mind
```

#### Статус передачи {#fst}

Клиент может запросить текущий статус передачи файла.

**Запрос (от клиента к серверу):**
```
<< fst|SESSION_ID\n
```

**Ответ сервера:**
```
>> fst|SESSION_ID|status\n
```

Где `status` может быть:
- `pending` — ожидание принятия получателем
- `accepted` — файл принят, порты выделены
- `transferring` — идет передача файла
- `completed` — передача успешно завершена
- `declined` — файл отклонен получателем
- `cancelled` — передача отменена одной из сторон

Пример:
```
fst|f4a3b2c1
fst|f4a3b2c1|transferring
```

#### Ограничения и особенности

- **Таймаут сессии:** После инициации сессия действительна 5 минут для принятия. После принятия — 10 минут для завершения передачи.
- **Диапазон портов:** Сервер использует диапазон портов 35000-35999 для передачи файлов (по умолчанию, настраивается).
- **Автоматическая очистка:** Устаревшие сессии автоматически удаляются сервером.
- **Проверка целостности:** Клиенты могут самостоятельно проверять хеш файла после передачи.
- **Бинарные данные:** Файлы передаются в бинарном виде без дополнительного кодирования.


---

## Примечания

### Использование через telnet

Благодаря текстовому формату протокол mSIM можно использовать напрямую через telnet или netcat. Пример сессии:

```
$ nc localhost 3215
ping
pong
auth|user|pass
ok|auth
msg|friend@example.com|Привет!
list
list|friend@example.com|Друг
```

### Обработка пакетов

Парсер должен:
1. Читать данные построчно до символа новой строки (`\n`)
2. Разделить строку на поля по символу `|` (неэкранированному)
3. Раскодировать экранированные символы в каждом поле
4. Для списков разделить поле `CONTENT` по запятой (`,`)

Пример обработки списка контактов:
```
list|friend@m1kc.tk|friend,vasya@poupkine.com|vasya,one@m1kc.tk|number
```

После разделения по запятой получится список контактов:
- `friend@m1kc.tk|friend`
- `vasya@poupkine.com|vasya`
- `one@m1kc.tk|number`

