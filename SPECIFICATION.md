# Спецификация протокола mSIM

**Авторы:** Мусатов М.Д., Солкин И.В.

---

## Введение

mSIM — лёгкий расширяемый протокол для обмена текстовыми сообщениями. Протокол разработан с учётом нетребовательности к ресурсам, масштабируемости и простоты реализации.

### Суть протокола

Протокол mSIM использует клиент-серверную архитектуру. Клиент подключается к серверу по TCP (порт 3215). Обмен данными происходит в виде пакетов.

Каждый пакет представляет собой одну строку в кодировке UTF-8, заканчивающуюся символом новой строки (`\n`). Это позволяет использовать протокол через telnet или netcat.

Структура пакета может быть в одном из следующих форматов:

1. **`TYPE\n`** — пакет только с типом (например, `ping\n`, `bye\n`, `list\n`, `stat\n`)

2. **`TYPE|CONTENT\n`** — пакет с типом и содержимым (например, `help\n`, `stat|user@example.com\n`, `hist|contact@example.com\n`)

3. **`TYPE|DESTINATION|CONTENT\n`** — пакет с типом, получателем и содержимым (например, `msg|recipient@example.com|Hello!\n`, `ack|sender@example.com|2024-01-01T12:00:00Z\n`)

Где:
- `TYPE`: Тип пакета (обязательное поле). Всегда первое поле в пакете.
- `DESTINATION`: Логин получателя (для исходящих пакетов от клиента) или отправителя (для входящих пакетов от сервера). Опциональное поле, присутствует только в формате с тремя частями. Для пакетов, адресованных серверу, это поле обычно отсутствует.
- `CONTENT`: Содержимое пакета. Может быть пустым или содержать дополнительные поля, разделённые символом вертикальной черты `|` (неэкранированным) или запятой `,` (для списков), в зависимости от типа пакета. Внутри `CONTENT` дополнительные поля также могут разделяться неэкранированным символом `|`.

**Важно:** Разделитель `|` между основными частями пакета (TYPE, DESTINATION, CONTENT) не экранируется. Экранирование применяется только к символам внутри самих полей. Например, в пакете `msg|user@example.com|Hello\|World\n` символ `|` между `msg` и `user@example.com` и между `user@example.com` и `Hello\|World` является разделителем полей, а `\|` внутри `Hello\|World` — экранированным символом, который будет интерпретирован как обычный `|`.

Пакеты разделяются символом новой строки (`\n`). Каждый пакет должен заканчиваться этим символом.

### Экранирование символов

Для передачи специальных символов внутри полей используется экранирование через обратный слэш (`\`). Экранируются следующие символы:

- `\|` — вертикальная черта (разделитель полей)
- `\,` — запятая (разделитель в списках)
- `\\` — обратный слэш
- `\n` — символ новой строки (внутри поля, не разделитель пакета)
- `\r` — символ возврата каретки

Обратный слэш перед любым другим символом интерпретируется как обычный обратный слэш (экранирование игнорируется).

Примеры:
- Для передачи логина `user|name` нужно написать `user\|name`
- Для передачи текста с новой строкой: `Первая строка\nВторая строка`
- Для передачи обратного слэша: `путь\\к\\файлу`
- Для передачи запятой в списке контактов: `id,with\,comma|nick`

**Таймаут соединения:** Сервер разрывает соединение, если клиент не подаёт признаков жизни в течение 120 секунд. Для поддержания соединения используйте команду `ping` (см. [Проверка связи](#проверка-связи)).

## Описание протокола

### Базовые типы пакетов

#### Успех

Пакет с типом `ok` оповещает об успешном завершении операции. В поле `CONTENT` может быть указано название операции (опционально). Формат: `ok|operation\n` или просто `ok\n`

#### Неудача

Пакет с типом `fail` оповещает о том, что запрошенную операцию не удалось выполнить. Это включает все типы ошибок: отказы в выполнении операции, внутренние ошибки сервера, неизвестные типы пакетов и т.д.

Формат: `fail|operation|description\n`

Где:
- `operation` — название операции, которая не удалась (например, `auth`, `reg`, `add`). Для внутренних ошибок, не связанных с конкретной операцией, это поле пустое.
- `description` — описание ошибки (опционально, может быть пустым). Если описание отсутствует, пакет может иметь формат `fail|operation|\n` или просто `fail|\n` для внутренних ошибок.

Примеры:
- `fail|auth|\n` — ошибка авторизации без описания
- `fail|auth|Invalid credentials\n` — ошибка авторизации с описанием
- `fail||Internal server error\n` — внутренняя ошибка сервера
- `fail|\n` — общая ошибка без деталей

### Основные возможности протокола

#### Проверка связи {#проверка-связи}

Используется для проверки связи и поддержания соединения в активном состоянии.

**Запрос (от клиента к серверу):**
```
<< ping\n
```

**Ответ сервера:**
```
>> pong\n
```

Пример:
```
ping
pong
```

#### Завершение сессии {#bye}

Используется для нормального завершения сессии. Клиент может отправить пакет `bye` для корректного отключения от сервера. Сервер также отправляет пакет `bye` при принудительном завершении сессии с указанием причины.

**Завершение сессии клиентом:**
```
<< bye\n
```

После отправки пакета `bye` клиент может закрыть соединение. Сервер также закрывает соединение после отправки ответа.

**Завершение сессии сервером:**

Сервер отправляет пакет `bye` при принудительном завершении сессии. Формат: `bye|reason|details\n`

Где:
- `reason` — причина завершения сессии:
  - `timeout` — таймаут (клиент не подавал признаков жизни в течение установленного времени)
  - `maintenance` — сервер уходит на обслуживание
  - `restart` — сервер перезагружается
- `details` — дополнительная информация (опционально):
  - Для `maintenance`: время завершения обслуживания в формате ISO 8601 (UTC), например `2024-01-01T13:00:00Z`
  - Для `restart`: время завершения перезагрузки в формате ISO 8601 (UTC), например `2024-01-01T12:05:00Z`
  - Для `timeout`: может быть пустым

Примеры:

Завершение сессии клиентом:
```
bye
```

Завершение сессии по таймауту:
```
>> bye|timeout|\n
```

Сервер уходит на обслуживание до 13:00 UTC:
```
>> bye|maintenance|2024-01-01T13:00:00Z\n
```

Сервер перезагружается, завершение в 12:05 UTC:
```
>> bye|restart|2024-01-01T12:05:00Z\n
```

**Примечание:** После получения пакета `bye` от сервера клиент должен закрыть соединение. После отправки пакета `bye` клиентом сервер закрывает соединение.

#### Справка {#help}

Используется для получения списка поддерживаемых команд.

**Запрос справки (от клиента к серверу):**
```
<< help\n
```

**Ответ сервера:**
```
>> help|ping,auth,reg,msg,ack,hist,hclear,stat,list,add,ren,del,bye,help\n
```

Ответ приходит в виде списка поддерживаемых команд, разделенных запятой (`,`).

Пример:
```
help
help|ping,auth,reg,msg,ack,hist,hclear,stat,list,add,ren,del,bye,help
```

**Примечание:** Команда `help` доступна без авторизации.

#### Авторизация {#auth}

Используется для авторизации на сервере.

**Запрос (от клиента к серверу):**
```
<< auth|login|password\n
```

**Ответ сервера:**
```
>> ok|auth\n
```

При неверной паре логин-пароль сервер отвечает `fail|auth|Invalid credentials\n`. Если клиент уже авторизован, сервер отправляет `ok|auth\n`.

Пример:
```
auth|myuser|mypass
ok|auth
```

#### Регистрация {#register}

Используется для создания новой учётной записи на сервере.

**Запрос (от клиента к серверу):**
```
<< reg|login|password\n
```

**Ответ сервера:**
```
>> ok|reg\n
```

Если аккаунт уже существует, сервер отвечает `fail|reg|User already exists\n`.

Пример:
```
reg|newuser|newpass
ok|reg
```

### Текстовые сообщения

#### Сообщение {#message}

Используется для отправки обычных текстовых сообщений адресату.

**Исходящее сообщение (от клиента к серверу):**
```
<< msg|friend|Привет!\n
```

**Входящее сообщение (от сервера к клиенту):**
```
>> msg|sender|Привет!|2024-01-01T12:00:00Z\n
```

В входящих сообщениях после текста добавляется время отправки в формате ISO 8601 (UTC). Формат: `YYYY-MM-DDTHH:mm:ssZ` (например, `2024-01-01T12:00:00Z`). Время всегда серверное и в UTC. Это время используется как уникальный идентификатор сообщения для подтверждения доставки.

Примеры:

Исходящее сообщение:
```
msg|friend@example.com|Привет, как дела?
```

Входящее сообщение:
```
msg|friend@example.com|Привет, как дела?|2024-01-01T12:00:00Z
```

Сообщение с экранированием (символ `|`):
```
msg|friend@example.com|Цена: 100\|200 рублей
```

Многострочное сообщение:
```
msg|friend@example.com|Первая строка\nВторая строка
```

#### Подтверждение доставки {#ack}

После получения входящего сообщения клиент может отправить подтверждение доставки серверу. Это позволяет отправителю узнать, что сообщение было доставлено получателю.

**Подтверждение доставки (от клиента к серверу):**
```
<< ack|sender|2024-01-01T12:00:00Z\n
```

Где:
- `sender` — логин отправителя сообщения
- `2024-01-01T12:00:00Z` — время отправки сообщения (timestamp из входящего сообщения), используемое как идентификатор

**Ответ сервера:**
```
>> ok|ack\n
```

Сервер пересылает подтверждение доставки отправителю сообщения.

**Подтверждение доставки (от сервера к отправителю):**
```
>> ack|recipient|2024-01-01T12:00:00Z\n
```

Где:
- `recipient` — логин получателя, который подтвердил доставку
- `2024-01-01T12:00:00Z` — время отправки исходного сообщения (идентификатор)

Пример:

Получение сообщения и подтверждение:
```
msg|friend@example.com|Привет!|2024-01-01T12:00:00Z
ack|friend@example.com|2024-01-01T12:00:00Z
ok|ack
```

Получение подтверждения отправителем:
```
ack|me@example.com|2024-01-01T12:00:00Z
```

**Примечание:** Подтверждение доставки опционально, но рекомендуется.

#### История сообщений {#hist}

Клиент может запросить историю сообщений с конкретным контактом. История хранится на сервере и включает как отправленные, так и полученные сообщения, а также их статус доставки.

**Запрос истории (от клиента к серверу):**
```
<< hist|contact@example.com\n
```

Или с ограничением количества сообщений:
```
<< hist|contact@example.com|100\n
```

Или с отступом и ограничением:
```
<< hist|contact@example.com|50|100\n
```

Где:
- Первый параметр (опционально) — максимальное количество сообщений (limit). Если не указан, возвращаются все сообщения.
- Второй параметр (опционально) — отступ (offset), количество сообщений, которые нужно пропустить от начала истории. Если не указан, используется 0.

Если не указаны оба параметра, сервер возвращает все доступные сообщения.

**Примечание:** Формат `hist|contact|offset|limit` означает: пропустить `offset` сообщений, затем вернуть до `limit` сообщений.

**Ответ сервера:**
```
>> hist|contact@example.com|msg|sender|Текст сообщения|2024-01-01T12:00:00Z|ackn,msg|recipient|Другое сообщение|2024-01-01T12:05:00Z|sent\n
```

Ответ приходит в виде списка сообщений, где каждое сообщение представлено в формате `msg|sender|text|timestamp|status`, сообщения разделены запятой (`,`).

Где:
- `sender` — логин отправителя (может быть текущий пользователь или контакт)
- `text` — текст сообщения
- `timestamp` — время отправки в формате ISO 8601 (UTC)
- `status` — статус доставки: `ackn` (доставлено, получено подтверждение ack) или `sent` (отправлено, но подтверждение не получено)

Примеры:

Запрос всех сообщений:
```
hist|friend@example.com
hist|friend@example.com|msg|me@example.com|Привет!|2024-01-01T12:00:00Z|ackn,msg|friend@example.com|Привет!|2024-01-01T12:01:00Z|ackn
```

Запрос первых 100 сообщений:
```
hist|friend@example.com|100
```

Запрос с отступом 50, максимум 100 сообщений:
```
hist|friend@example.com|50|100
```

#### Очистка истории {#hclear}

Клиент может очистить историю сообщений с конкретным контактом.

**Очистка истории (от клиента к серверу):**
```
<< hclear|contact@example.com\n
```

**Ответ сервера:**
```
>> ok|hclear\n
```

Если история успешно очищена, сервер отвечает `ok|hclear\n`. Если контакта нет в списке, сервер отвечает `fail|hclear|Contact not found\n`.

Пример:
```
hclear|friend@example.com
ok|hclear
```

### События статуса контактов

Сервер автоматически отправляет клиенту уведомления о подключении и отключении пользователей из его списка контактов.

#### Запрос статусов контактов

Клиент может запросить текущие статусы (онлайн/оффлайн) всех пользователей из своего списка контактов.

**Запрос статусов (от клиента к серверу):**
```
<< stat\n
```

Или для запроса статуса конкретного пользователя:

```
<< stat|user@example.com\n
```

**Ответ сервера:**

При запросе всех контактов:
```
>> stat|user1@example.com|on,user2@example.com|off,user3@example.com|on\n
```

При запросе конкретного пользователя:
```
>> stat|user@example.com|on\n
```

Или если пользователь оффлайн:
```
>> stat|user@example.com|off\n
```

Ответ приходит в виде списка статусов, где каждый статус представлен в формате `user|status`, статусы разделены запятой (`,`). Значение `status` может быть `on` (онлайн) или `off` (оффлайн).

Если указанный пользователь не существует, сервер отвечает `fail|stat|User not found\n`.

Примеры:

Запрос статусов всех контактов:
```
stat
stat|friend1@example.com|on,friend2@example.com|off,friend3@example.com|on
```

Запрос статуса конкретного пользователя:
```
stat|friend1@example.com
stat|friend1@example.com|on
```

Если пользователь не существует:
```
stat|nonexistent@example.com
fail|stat|User not found
```

#### Подключение пользователя {#on}

Когда пользователь из списка контактов подключается к серверу, клиент получает уведомление.

**Событие подключения (от сервера к клиенту):**
```
>> on|user@example.com\n
```

Где `user@example.com` — логин пользователя из списка контактов, который подключился.

Пример:
```
on|friend@example.com
```

#### Отключение пользователя {#off}

Когда пользователь из списка контактов отключается от сервера, клиент получает уведомление.

**Событие отключения (от сервера к клиенту):**
```
>> off|user@example.com\n
```

Где `user@example.com` — логин пользователя из списка контактов, который отключился.

Пример:
```
off|friend@example.com
```

**Примечание:** События о статусе отправляются только для пользователей из списка контактов клиента.

### Работа со списком контактов

#### Запрос списка

Запрашивает у сервера список контактов. Ответ приходит в виде списка контактов, где каждый контакт представлен в формате `id|nick`, контакты разделены запятой (`,`).

```
<< list\n

>> list|friend@m1kc.tk|friend,vasya@poupkine.com|vasya,one@m1kc.tk|number\n
```

Пример:
```
list
list|friend@m1kc.tk|friend,vasya@poupkine.com|vasya,one@m1kc.tk|number
```

#### Добавление контакта

Для добавления контакта используется пакет типа `add`. В поле `CONTENT` передаются id контакта и назначаемый ему ник. Если ник не указан, в качестве ника будет использован id контакта.

**Важно:** В список контактов можно добавлять только существующих пользователей. Если указанный пользователь не существует в системе, сервер отвечает пакетом `fail|add|User not found\n`.

Типичный случай:

```
<< add|wellie@server.ru|One more friend\n

>> ok|add\n
```

Или без указания ника (ник будет равен id контакта):

```
<< add|wellie@server.ru\n

>> ok|add\n
```

Если пользователь не существует:
```
<< add|nonexistent@server.ru|Friend\n

>> fail|add|User not found\n
```

Примеры:

С указанием ника:
```
add|wellie@server.ru|One more friend
ok|add
```

Без указания ника (ник будет равен id контакта):
```
add|wellie@server.ru
ok|add
```

Если пользователь не существует:
```
add|nonexistent@server.ru|Friend
fail|add|User not found
```

#### Переименование контакта

Контакты переименовываются с помощью пакета типа `ren`. В поле `CONTENT` передаются id контакта и его новый ник. Если такого контакта в списке нет, сервер отвечает `fail|ren|Contact not found\n`.

```
<< ren|friend@m1kc.tk|Enemy\n

>> ok|ren\n
```

Пример:
```
ren|friend@m1kc.tk|Enemy
ok|ren
```

#### Удаление контакта

Для удаления контакта используется пакет типа `del`. В поле `CONTENT` передаётся id контакта. Если такого контакта в списке нет, сервер отвечает `fail|del|Contact not found\n`.

```
<< del|one@m1kc.tk\n

>> ok|del\n
```

Пример:
```
del|one@m1kc.tk
ok|del
```


---

## Примечания

### Использование через telnet

Благодаря текстовому формату протокол mSIM можно использовать напрямую через telnet или netcat. Пример сессии:

```
$ nc localhost 3215
ping
pong
auth|user|pass
ok|auth
msg|friend@example.com|Привет!
list
list|friend@example.com|Друг
```

### Обработка пакетов

Парсер должен:
1. Читать данные построчно до символа новой строки (`\n`)
2. Разделить строку на поля по символу `|` (неэкранированному)
3. Раскодировать экранированные символы в каждом поле
4. Для списков разделить поле `CONTENT` по запятой (`,`)

Пример обработки списка контактов:
```
list|friend@m1kc.tk|friend,vasya@poupkine.com|vasya,one@m1kc.tk|number
```

После разделения по запятой получится список контактов:
- `friend@m1kc.tk|friend`
- `vasya@poupkine.com|vasya`
- `one@m1kc.tk|number`

